from .abstract_partitioning_method import AbstractPartitioningMethod
from ..config import TL_DIR
import hashlib
import numpy as np
import os
import re
import subprocess


class FMPartitioning(AbstractPartitioningMethod):

    # assumes this file to be in $ROOT/py/partitioning; then, the rundir is at $ROOT/fm_rundir
    run_folder = os.path.join(TL_DIR, "ext", "modularity", "rundir")
    if not os.path.exists(run_folder):
        os.makedirs(run_folder)
    exe_folder = os.path.join(TL_DIR, "ext", "modularity", "FastCommunity_w_GPL_v1.0.1")
    fm_exe = os.path.join(exe_folder, "FastCommunity_wMH")
    if not os.path.exists(fm_exe):
        curr_dir = os.getcwd()
        os.chdir(exe_folder)
        subprocess.call(["make"])
        os.chdir(curr_dir)

    opt_num_partitions = {}

    def __init__(self, num_partitions=None):
        super().__init__(num_partitions=num_partitions, weighted=False)

    @property
    def name(self):
        return "fm_partitioning"

    def _partition_impl(self, problem, all_tm_files=[]):
        G = problem.G
        topo = problem.name

        # write weighted pairs to file
        wpfile = os.path.join(self.run_folder, topo + ".wpairs")
        with open(wpfile, "w") as outF:
            seen = set()
            for (u, v, c) in G.edges.data("capacity"):
                seen.add((u, v))
                wt = c
                outF.write("%d\t%d\t%d\n" % (u, v, wt))

        if not hasattr(self, "_num_partitions"):
            # Run without num partitions argument to determine optimal number
            # of partitions based on modularity
            cmd = (
                self.fm_exe
                + " -f "
                + wpfile
                + ' | grep ^Q | sort -g -r -k3 | head -n 1 | sed -e "s/\[/ /g" | sed -e "s/\]/ /g" | awk \'{print $2}\''
            )
            print("cmd=[{}]".format(cmd))

            self._num_partitions = len(G.nodes) - int(os.popen(cmd).read())
            print("opt #partitions= ", self._num_partitions)

        # Run with num partitions argument, save to temporary output file
        fm_param = len(G.nodes) - self._num_partitions
        cmd = self.fm_exe + " -f " + wpfile + " -c " + str(fm_param)
        print("cmd=[{}]".format(cmd))

        temp_fname = hashlib.md5(np.int64(np.random.randint(2 ** 31 - 1))).hexdigest()
        with open(temp_fname, "w") as w:
            subprocess.call(cmd, shell=True, stdout=w)

        # Extract time
        output = os.popen('grep "Total Time:" {}'.format(temp_fname)).read()
        match = re.match("Total Time: (\d+(\.\d+)?) seconds", output)
        self.runtime = float(match.group(1))

        # Extract modularity score
        output = os.popen(
            'grep "^Q\['
            + str(fm_param)
            + '\]" '
            + temp_fname
            + ' | sed -e "s/\[/ /g" | sed -e "s/\]/ /g" | awk \'{print $4}\''
        ).read()
        self.modularity = float(output)
        print("Modularity:", self.modularity)

        # Remove temporary output file
        os.remove(temp_fname)

        # Read partition vector from output file generated by FM
        partition_vector = np.ones(len(G.nodes), dtype=np.int32) * -1
        currgroup = -1
        with open(os.path.join(self.run_folder, topo + "-fc_a.groups"), "r") as groups:
            for line in groups:
                if line.startswith("GROUP"):
                    currgroup += 1
                else:
                    partition_vector[int(line)] = currgroup

        assert np.sum(partition_vector == -1) == 0
        return partition_vector
